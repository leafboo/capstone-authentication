import express, { type Request, type Response, type NextFunction } from "express";
import bcrypt from "bcrypt";
import { pool } from './mysqlConnection.js'
import jwt from 'jsonwebtoken';
import 'dotenv/config.js';


type User = {
    Id: number;
    UserName: string;
    Email: string;
    Salt: string;
    Hash: string;
}


// remember: Every line of code is a potential vulnerability

const app = express();

app.use(express.json()); // middleware that converst JSON from request to JavaScript object

app.get("/", (req, res) => {
    res.status(200);
    res.send("Welcome to the authentication API");
});

app.get("/users", authenticateToken, (req, res) => {
    const user = res.locals.user;

    if (user) {
        res.status(200).json(user);
    } else {
        res.status(403).json({message: "Access denied"})
    }
    
})

app.post("/users", async (req, res) => {

    if (!req.body.password) {
        return res.send("body should contain password and should not be empty");
        
    }
    
    try {
        const salt = await bcrypt.genSalt();
        const hashedPassword = await bcrypt.hash(req.body.password, salt);

        const query = 'INSERT INTO Users(UserName, Email, Salt, Hash) VALUES(?, ?, ?, ?);'
        const result = await pool.query(query, [req.body.userName, req.body.email, salt, hashedPassword]);
        res.status(201);
        res.send(result);
    } catch (err) {
        console.error(err)
        res.status(500);
    }
});

app.post("/users/login", async (req, res) => {
    const query = 'SELECT * FROM Users WHERE UserName = ? OR Email = ? ;';
    const [ results ] = await pool.query(query, [req.body.userName, req.body.email]); // select the user first 
    const data: User[] = JSON.parse(JSON.stringify(results));
   
    const passwordInput = req.body.password;
    
    
    
    if (data.length === 0 || data[0] === undefined) {
        res.status(404);
        res.send("User not found");
        return;
    }
    try {
        const passwordDB = data[0].Hash;
        if ( await bcrypt.compare(passwordInput, passwordDB) ) {

            const user = data[0]; // payload
            const accessToken = jwt.sign(user, process.env.ACCESS_TOKEN_SECRET); // header is automatically generated by the package I think
            res.json({ accessToken: accessToken });
            res.send("Successfully logged in")
        } else {
            res.send("Wrong password. Try again.")
        }
    } catch (err) {
        res.status(500);
    }
    // console.log(rows?[0].Hash);
})

function authenticateToken(req: Request, res: Response, next: NextFunction)  {
    
    if (!req.headers.authorization || !req.headers) {
        return res.status(401);
    }
    

    const authHeader = req.headers.authorization; // find out what is the return value of req.headers
    const token = authHeader.split(' ')[1];

    if (token === undefined || token === null) {
        return res.status(401).json({message:'Token verification failed'});
    }

    try {
        const decode = jwt.verify(token, process.env.ACCESS_TOKEN_SECRET);
        res.locals.user = decode;
        next();
    } catch (err) {
        return res.status(403);
    }
    
}

app.listen(3000, () => {
    console.log("Server is running in localhost:3000");
})